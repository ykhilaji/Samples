---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by grifon.
--- DateTime: 06/11/2018 00:44
---
logger = require('log')

box.cfg {
    wal_mode = 'none',
    checkpoint_interval = 0,
    log_level = 5
}

--The trigger-function will be executed whenever a replace() or insert() or update() or upsert() or delete() happens to a tuple in <space-name>.
function on_replace(old, new)
    logger.info('[On replace] old: %s, new: %s', old, new)
end

--The trigger-function will be executed whenever a replace() or insert() or update() or upsert() or delete() happens to a tuple in <space-name>.
--Since a before_replace trigger function has the extra capability of making a change to the old tuple,
--it also can have extra overhead, to fetch the old tuple before making the change.
--Therefore an on_replace trigger is better if there is no need to change the old tuple.
--However, this only applies for the memtx engine â€“ for the vinyl engine, the fetch will happen for either kind of trigger.
--(With memtx the tuple data is stored along with the index key so no extra search is necessary;
--with vinyl that is not the case so the extra search is necessary.)
function before_replace(old, new)
    logger.info('[Before replace] old: %s, new: %s', old, new)
    if new == nil then
        return new
    end

    if new[1] % 2 == 0 or new[1] < 10 then
    return new
    else
    return old -- do not change tuples with odd key
    end
    end

box.once('init', function()
    logger.info('Creating index')
    box.schema.sequence.create('id', { start = 0, min = 0, step = 1, cycle = false })
    logger.info('Creating space')
    box.schema.space.create('sample', { if_not_exists = false, engine = 'memtx' })
    logger.info('Creating primary index')
    box.space.sample:create_index('primary', { sequence = 'id', type = 'HASH', unique = true, if_not_exists = true })
    logger.info('Creating secondary index')
    box.space.sample:create_index('secondary', { type = 'TREE', unique = false, if_not_exists = true, parts = { { 2, 'integer', is_nullable = false }, { 3, 'string', is_nullable = true } } })
    box.space.sample:on_replace(on_replace)
    box.space.sample:before_replace(before_replace)
    logger.info('Database has been initialized')
end
)

function insert(space_id, ...)
    local arg = {...}
    box.space[space_id]:insert(arg)
end

function delete(space_id, ...)
    local arg = {...}
    box.space[space_id]:delete(arg)
end

function replace(space_id, ...)
    local arg = {...}
    box.space[space_id]:replace(arg)
end

function update(space_id, ...)
    local arg = {...}
    box.space[space_id]:update(unpack(arg))
end

function upsert(space_id, ...)
    local arg = {...}
    box.space[space_id]:upsert(unpack(arg))
end


id = box.space.sample.id
insert(id, nil, 1, '2')
logger.info(box.space.sample:select())
delete(id, 0)
logger.info(box.space.sample:select())
insert(id, nil, 1, '2')
logger.info(box.space.sample:select())
replace(id, 1, 2, '1')
logger.info(box.space.sample:select())
update(id, 1, {{'=', 2, 100}, {'!', 4, 'fourth column'}})
logger.info(box.space.sample:select())
upsert(id, {2, 3, '4'}, {{'=', 2, 100}, {'!', 4, 'updated fourth column'}})
upsert(id, {1, 3, '4'}, {{'=', 2, 100}, {'!', 4, 'updated fourth column'}})
logger.info(box.space.sample:select())

logger.info(box.space.sample.index.secondary:select({1, '1'}, {offset=0, limit=1, iterator='GT'}))